function xPort = dcsFcnLinkPortAllGet(xConfiguration,xModule)
% DCSFCNLINKPORTALLGET generate list of all ports in configuration from the
% orignal module XML. 
% Part of DIVe Configuration Standard for reuse in platform/configurator.
%
% Syntax:
%   xPort = dcsFcnLinkPortAllGet(xConfiguration,xModule)
%
% Inputs:
%   xConfiguration.ModuleSetup(n).name  - string with module setup name
%     xModule(n)  - structure vector with module XML content
%
% Outputs:
%   xPort - structure with fields (not complete): 
%     .name  - string with port name
%     .type  - string with port type (physics,control,sensor,actuator,boundary,hmi,info)
%     .unit  - string with port unit
%     .manualDescription    - string with manual port description
%     .autoDescription      - string with automatic port description
%     .connectorName        - string with connector name
%     .connectorType        - string connector type (DIVe predefied type)
%     .connectorOrientation - string connector orientation (positive/ 
%                             negative)
%     .quantity             - string with quantity of port value
%     .functionalChain      - string name of functional chain
%     .chainPosition        - string with integer of connector default
%                             position
%     .moduleSpecies  - string with name module species
%     .moduleContext  - string with name module context (e. g. human, physics) 
%     .moduleSetup    - string of containing module in setup (e. g. eng1)
%     .ioType         - string with port I/O type (inport,outport)
%     .nameUnique     - string with configuration-wide unique port name by
%                       combination of ModuleSetup name and port name
%     .state          - string with (open, const, signal)
%     .log            - boolean, if port should be logged
%     .select         - boolean, if port is currently selected
%     .minPhysicalRange - scalar with minimal physical value range
%     .maxPhysicalRange - scalar with maximal physical value range
% 
%
% Example: 
%   xPort = dcsFcnLinkPortAllGet(data.cfg.Configuration,data.cfg.xml.Module)
%
% Author: Rainer Frey, TP/EAD, Daimler AG
%  Phone: +49-711-17-34246
% MailTo: rainer.r.frey@daimler.com
%   Date: 2015-08-17

% initialize output
xPort = struct('name',{},'type',{},'unit',{},'manualDescription',{},...
               'autoDescription',{},'connectorName',{},'connectorType',{},...
               'connectorOrientation',{},'quantity',{},'functionalChain',{},...
               'chainPosition',{},'moduleSpecies',{},'moduleContext',{},...
               'moduleSetup',{},'ioType',{},'nameUnique',{},'state',{},...
               'log',{},'select',{},'minPhysicalRange',{},'maxPhysicalRange',{});
           
for nIdxModule = 1:numel(xModule)
    %% add inports to general list
    if isfield(xModule(nIdxModule).Interface,'Inport')
        % inports creation with structure initialization via cell arrays
        nInport = numel(xModule(nIdxModule).Interface.Inport);
        xPortAdd = struct('name',{xModule(nIdxModule).Interface.Inport.name},...
                'type',{xModule(nIdxModule).Interface.Inport.type},...
                'unit',{xModule(nIdxModule).Interface.Inport.unit},...
                'manualDescription',{xModule(nIdxModule).Interface.Inport.manualDescription},...
                'autoDescription',{xModule(nIdxModule).Interface.Inport.autoDescription},...
                'connectorName',{xModule(nIdxModule).Interface.Inport.connectorName},...
                'connectorType',{xModule(nIdxModule).Interface.Inport.connectorType},...
                'connectorOrientation',{xModule(nIdxModule).Interface.Inport.connectorOrientation},...
                'quantity',{xModule(nIdxModule).Interface.Inport.quantity},...
                'functionalChain',{xModule(nIdxModule).Interface.Inport.functionalChain},...
                'chainPosition',{xModule(nIdxModule).Interface.Inport.chainPosition},...
                'moduleSpecies',repmat({xModule(nIdxModule).species},1,nInport),...
                'moduleContext',repmat({xModule(nIdxModule).context},1,nInport),...
                'moduleSetup',repmat({xConfiguration.ModuleSetup(nIdxModule).name},1,nInport),...
                'ioType','inport',...
                'nameUnique',cellfun(@(x)[xConfiguration.ModuleSetup(nIdxModule).name '_' x],...
                    {xModule(nIdxModule).Interface.Inport.name},'UniformOutput',false),...
                'state',repmat({'open'},1,nInport),...
                'log',repmat({false},1,nInport),...
                'select',repmat({false},1,nInport),...
                'minPhysicalRange',{xModule(nIdxModule).Interface.Inport.minPhysicalRange},...
                'maxPhysicalRange',{xModule(nIdxModule).Interface.Inport.maxPhysicalRange});
        xPort = structConcat(xPort,xPortAdd);
    end % if isfield
    
    %% add outports to general list
    if isfield(xModule(nIdxModule).Interface,'Outport')
        % outports creation with structure initialization via cell arrays
        nOutport = numel(xModule(nIdxModule).Interface.Outport);
        xPortAdd = struct('name',{xModule(nIdxModule).Interface.Outport.name},...
            'type',{xModule(nIdxModule).Interface.Outport.type},...
            'unit',{xModule(nIdxModule).Interface.Outport.unit},...
            'manualDescription',{xModule(nIdxModule).Interface.Outport.manualDescription},...
            'autoDescription',{xModule(nIdxModule).Interface.Outport.autoDescription},...
            'connectorName',{xModule(nIdxModule).Interface.Outport.connectorName},...
            'connectorType',{xModule(nIdxModule).Interface.Outport.connectorType},...
            'connectorOrientation',{xModule(nIdxModule).Interface.Outport.connectorOrientation},...
            'quantity',{xModule(nIdxModule).Interface.Outport.quantity},...
            'functionalChain',{xModule(nIdxModule).Interface.Outport.functionalChain},...
            'chainPosition',{xModule(nIdxModule).Interface.Outport.chainPosition},...
            'moduleSpecies',repmat({xModule(nIdxModule).species},1,nOutport),...
            'moduleContext',repmat({xModule(nIdxModule).context},1,nOutport),...
            'moduleSetup',xConfiguration.ModuleSetup(nIdxModule).name,...
            'ioType',repmat({'outport'},1,nOutport),...
            'nameUnique',cellfun(@(x)[xConfiguration.ModuleSetup(nIdxModule).name '_' x],...
                    {xModule(nIdxModule).Interface.Outport.name},'UniformOutput',false),...
            'state',repmat({'open'},1,nOutport),...
            'log',repmat({false},1,nOutport),...
            'select',repmat({false},1,nOutport),...
            'minPhysicalRange',{xModule(nIdxModule).Interface.Outport.minPhysicalRange},...
            'maxPhysicalRange',{xModule(nIdxModule).Interface.Outport.maxPhysicalRange});
        xPort = structConcat(xPort,xPortAdd);
    end
end

%% transfer logging signals
if isfield(xConfiguration,'Interface') && isfield(xConfiguration.Interface,'Logging')
    % create unique port list from logging entries
    cPortLog = arrayfun(@(x)[x.modelRef '_' x.name],xConfiguration.Interface.Logging,'UniformOutput',false);
    cPortList = {xPort.nameUnique};
    
    % match and transfer log setting
    bLog = ismember(cPortList,cPortLog);
    [xPort(bLog).log ] = deal(true);
end
return
